#! /bin/bash
echo "bash shell is a dialect of bourne again shell"
which bash
# name of the script file
echo "Name of the script file is: $0 and the processid is $$"

# Variables, prompts ====================================
NAME="Jonaq"
echo "Hello, I'm $NAME"
read -p "What's you name? " ANSWER
echo "Nice to meet you, $ANSWER!"

# If Else ===============================================
# the space after [ is necessary, the space around == are necessary. the space before ] is necessary. Not intuitive
if [ "$ANSWER" == "Jonaq" ]      
    then
    echo "You're formally a fatso!"
elif [ "$ANSWER" == "Niyor" ]
    then
    echo "You're informally fatso!"
else echo "You're a stranger!"
fi

# Comparing integers
NUM1=4
NUM2=3
if [ $NUM1 -gt $NUM2 ]
    then
    echo "Bash says $NUM1 is greater than $NUM2"
fi

# Switch Case
read -p "Are you an adult? Y/N: " ANSWER
# Weird syntax coming through...
case "$ANSWER" in
	[yY] | [yY][eE][sS])
		echo "Go and vote"
		;;
	[nN] | [nN][oO])
		echo "Sorry, you can't vote"
		;;
	*)
		echo "Say yes or no pls"
		;;
	esac

# File I/O ==============================================
FILE="test.txt"
# readonly FILE
if [ -f "$FILE" ]
then
	echo "$FILE is a file in working directory"
else
	echo "$FILE is not a file in working directory"
fi
unset FILE # Can't unset a readonly variable

# Loops =================================================
# for/while/until do done, break, continue. nesting.
NAMES="Brad Kevin Alice Mark"
for NAME in $NAMES
do
	echo "Hello $NAME"
done

FILES=$(ls *.txt)
for FILE in $FILES
do
	echo "Found a file named: $FILE"
done

# while loop to read a file line by line
LINE=1
while read -r CURRENT_LINE
do
	echo "$LINE: $CURRENT_LINE"
	((LINE++))
done < "$FILE"


# Functions, Positional parameters ======================
function sayHello()
{
	echo "Hello from inside a function, $1"
}

sayHello "Happy person"

echo "This file was created by the shell script quick_starts/shell.txt" >> "/mnt/c/Users/jonaq/Desktop/test.txt"

# #! usr/bin/py included inside a .py file will tell bash that that file has to be executed using python

# ================= TERMINAL TUTORIAL ===================

# ls and flags, -l, -a. mkdir, cd, cp, mv, rm. -r for directory. 
# ~ means home, $ means regular privileges
# pwd means present working directory
# press TAB key to autocomplete your command, TAB twice to see all options
# pushd <directory> to work in another directory, popd to return: in case you don't want to deal with long paths
# linux doesn't really need the extensions. file <filename> for more info on the file.
# locate <filename> or locate <parts of filename> to find. update the search database using sudo updatedb
# which <command> to find a command
# up arrow to go through your history of commands. use history command to list the last 1000 unique commands. then call that command using the number as in !<nu> eg. !12. Default location for history is ~/.bash_history. history -c to clear the history of the current shell.
# whatis <command> for a short description. apropos <keyword> to find a command candidate. man for manual on a command.
# touch <filename> to create an empty file, or update the last modified date
# * is the wildcard string
# rmdir only removes empty directories
# cat <filename> to just list the text file. cat >> <filename> to append info into files. cat > to overwrite. also, cat file1 file2 concatenates file1 to file2
# more to page through. less to read through, easier. q to quit from both.

# piping command example (redirection): history | less
# executable < file to rewire the input of the program to this file
# executable > file to rewire the output of the program to this file. > overwrites, >> appends.
# e.g. executable.out < inputs.txt > outputs.txt 

# sudo -s to keep running as the root
# su - <user> to become <user> and go to his directory and settings and stuff. su <user> without - will make me <user> but won't change working directory or settings
# users command to see who is logged in

# file permissions: read, write, execute. rwx for user, group, everyone. 
# chmod to change mode. eg, chmode +X <filename> to make the file executable. or use chmod 700 <filename> to give me all permissions and nobody else gets anything. 
# Directories need the execute bit set in order to be seen by others (searchable), read to run ls -a, write to be able to rename, create or remove files from a directory. e.g. if you have w on a file inside a directory but not w on the directory, you can edit the file but can't delete it.

# ctrl + c to stop a command.
# killall <application> to kill all processes for the app
# ctrl + D to say, I'm done with all input, and close the terminal. 
# mail from shell (needs some config, uses mailutils package), links browser
# Aptitude is the default package manager. apt-cache search program (or *programName*) to see what is available in apt. apt-cache policy <app name> to see if your istalled version is the latest version. Install a .deb file by using sudo dpkg -i <filename>
# grep to find text in all files in current directory. -i to ignore case, -n to include line numbers as well. grep -flags "string" ./*
# crontabs to schedule task, eg. upgrade your softwares every Sunday at 5 am etc.

# scripting:
# variable types: local, environment, shell variables.
# scalar variable
# operators specific to bash shell: works inside square braces
# Arithmetic: + - \* / % = == !=
# Relational: -eq -ne -gt -lt -ge -le
# Boolean: ! -o -a
# String: = != -z -n str
# File test: -d -e -f -p -t -u -r -w -x -s 
